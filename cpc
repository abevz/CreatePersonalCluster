#!/bin/bash

# =============================================================================
# CPC (Cluster Provision & Configure) - Main Script
# =============================================================================
# Enhanced with modular architecture for better maintainability

# Color definitions (kept for backward compatibility)
export GREEN='\033[32m'
export RED='\033[0;31m'
export YELLOW='\033[0;33m'
export BLUE='\033[1;34m'
export ENDCOLOR='\033[0m'

# --- Load Modular Architecture ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load configuration first
if [ -f "$SCRIPT_DIR/config.conf" ]; then
    source "$SCRIPT_DIR/config.conf"
fi

# Load libraries
for lib in "$SCRIPT_DIR/lib"/*.sh; do
    [ -f "$lib" ] && source "$lib"
done

# Load modules  
for module in "$SCRIPT_DIR/modules"/*.sh; do
    [ -f "$module" ] && source "$module"
done

# Set REPO_PATH for modules
export REPO_PATH="$SCRIPT_DIR"

# Configuration (legacy, will be moved to config.conf)
CONFIG_DIR="$HOME/.config/cpc" # Updated for CreatePersonalCluster project
REPO_PATH_FILE="$CONFIG_DIR/repo_path"
CLUSTER_CONTEXT_FILE="$CONFIG_DIR/current_cluster_context"
CPC_ENV_FILE="cpc.env" # Expect this in the repo root, Changed from CCR_ENV_FILE and ccr.env

# --- Helper Functions ---
check_required_commands() {
  for cmd in "$@"; do
    if ! command -v "$cmd" &> /dev/null; then
      echo -e "${RED}Error: '$cmd' is required but not installed. Please install it before proceeding.${ENDCOLOR}" >&2
      exit 1
    fi
  done
}
export -f check_required_commands

get_repo_path() {
  if [ -f "$REPO_PATH_FILE" ]; then
    cat "$REPO_PATH_FILE"
  else
    echo -e "${RED}Repository path not set. Run 'cpc setup-cpc' to set this value.${ENDCOLOR}" >&2 # Changed from ccr setup-ccr
    exit 1
  fi
}
export -f get_repo_path

get_current_cluster_context() {
  if [ -f "$CLUSTER_CONTEXT_FILE" ]; then
    cat "$CLUSTER_CONTEXT_FILE"
  else
    echo -e "${RED}Error: No cpc context set.${ENDCOLOR}" >&2
    echo -e "${BLUE}The cpc context determines the Tofu workspace and associated configuration (e.g., OS type).${ENDCOLOR}" >&2
    echo -e "${BLUE}Please set a context using 'cpc ctx <workspace_name>'.${ENDCOLOR}" >&2
    
    # Attempt to get repo_path to list workspaces.
    # This relies on REPO_PATH_FILE being set by 'cpc setup-cpc'.
    if [ -f "$REPO_PATH_FILE" ]; then
      local repo_p_for_listing
      repo_p_for_listing=$(cat "$REPO_PATH_FILE")
      if [ -d "$repo_p_for_listing/terraform" ]; then
        echo -e "${BLUE}Available Tofu workspaces in '$repo_p_for_listing/terraform' (use one of these for <workspace_name>):${ENDCOLOR}" >&2
        # Ensure tofu command is available for listing or provide a message
        if command -v tofu &> /dev/null; then
          (cd "$repo_p_for_listing/terraform" && tofu workspace list | sed 's/^*/  /') >&2
        else
          echo -e "${YELLOW}  'tofu' command not found. Cannot list workspaces. Please ensure OpenTofu is installed and in your PATH.${ENDCOLOR}" >&2
        fi
      else
        echo -e "${YELLOW}Warning: Cannot list Tofu workspaces. Terraform directory not found at '$repo_p_for_listing/terraform'.${ENDCOLOR}" >&2
      fi
    else
      echo -e "${YELLOW}Warning: Cannot list Tofu workspaces. Repository path not set. Run 'cpc setup-cpc'.${ENDCOLOR}" >&2
    fi
    echo -e "${BLUE}Typically, the context/workspace should be one of: debian, ubuntu, rocky.${ENDCOLOR}" >&2
    exit 1
  fi
}
export -f get_current_cluster_context

# Check if secrets are already loaded
check_secrets_loaded() {
  if [ -z "$PROXMOX_HOST" ] || [ -z "$PROXMOX_USERNAME" ] || [ -z "$VM_USERNAME" ]; then
    echo -e "${RED}Error: Secrets not loaded. This command requires SOPS secrets to be loaded.${ENDCOLOR}" >&2
    echo -e "${BLUE}Please run 'cpc load_secrets' first or ensure cpc.env is properly configured.${ENDCOLOR}" >&2
    exit 1
  fi
}
export -f check_secrets_loaded

# Load sensitive data from secrets.sops.yaml using SOPS
load_secrets() {
  local repo_root
  repo_root=$(get_repo_path)
  local secrets_file="$repo_root/terraform/secrets.sops.yaml"
  
  if [ ! -f "$secrets_file" ]; then
    echo -e "${RED}Error: secrets.sops.yaml not found at $secrets_file${ENDCOLOR}" >&2
    exit 1
  fi
  
  # Check if sops is installed
  if ! command -v sops &> /dev/null; then
    echo -e "${RED}Error: 'sops' is required but not installed. Please install it before proceeding.${ENDCOLOR}" >&2
    exit 1
  fi
  
  # Check if jq is installed
  if ! command -v jq &> /dev/null; then
    echo -e "${RED}Error: 'jq' is required but not installed. Please install it before proceeding.${ENDCOLOR}" >&2
    exit 1
  fi
  
  echo -e "${BLUE}Loading secrets from secrets.sops.yaml...${ENDCOLOR}"
  
  # Export sensitive variables from SOPS
  export PROXMOX_HOST
  export PROXMOX_USERNAME  
  export PROXMOX_PASSWORD
  export VM_USERNAME
  export VM_PASSWORD
  export VM_SSH_KEY
  export AWS_ACCESS_KEY_ID
  export AWS_SECRET_ACCESS_KEY
  export AWS_DEFAULT_REGION
  
  # Load secrets using sops, convert to JSON, then parse with jq
  local secrets_json
  secrets_json=$(sops -d "$secrets_file" 2>/dev/null | python3 -c "import sys, yaml, json; json.dump(yaml.safe_load(sys.stdin), sys.stdout)")
  
  if [ $? -ne 0 ]; then
    echo -e "${RED}Error: Failed to decrypt secrets.sops.yaml. Check your SOPS configuration.${ENDCOLOR}" >&2
    exit 1
  fi
  
  # Parse secrets from JSON
  PROXMOX_HOST=$(echo "$secrets_json" | jq -r '.virtual_environment_endpoint' | sed 's|https://||' | sed 's|:8006/api2/json||')
  PROXMOX_USERNAME=$(echo "$secrets_json" | jq -r '.proxmox_username')
  PROXMOX_PASSWORD=$(echo "$secrets_json" | jq -r '.virtual_environment_password')
  VM_USERNAME=$(echo "$secrets_json" | jq -r '.vm_username')
  VM_PASSWORD=$(echo "$secrets_json" | jq -r '.vm_password')
  VM_SSH_KEY=$(echo "$secrets_json" | jq -r '.vm_ssh_keys[0]')
  
  # Parse MinIO/S3 credentials for Terraform backend
  AWS_ACCESS_KEY_ID=$(echo "$secrets_json" | jq -r '.minio_access_key')
  AWS_SECRET_ACCESS_KEY=$(echo "$secrets_json" | jq -r '.minio_secret_key')
  AWS_DEFAULT_REGION="us-east-1"  # Set default region for MinIO
  
  # Verify that all required secrets were loaded
  if [ -z "$PROXMOX_HOST" ] || [ -z "$PROXMOX_USERNAME" ] || [ -z "$PROXMOX_PASSWORD" ] || [ -z "$VM_USERNAME" ] || [ -z "$VM_PASSWORD" ] || [ -z "$VM_SSH_KEY" ] || [ -z "$AWS_ACCESS_KEY_ID" ] || [ -z "$AWS_SECRET_ACCESS_KEY" ]; then
    echo -e "${RED}Error: Failed to load one or more required secrets from secrets.sops.yaml${ENDCOLOR}" >&2
    echo -e "${BLUE}Required secrets: PROXMOX_HOST, PROXMOX_USERNAME, PROXMOX_PASSWORD, VM_USERNAME, VM_PASSWORD, VM_SSH_KEY, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY${ENDCOLOR}" >&2
    exit 1
  fi
  
  echo -e "${BLUE}Successfully loaded secrets (PROXMOX_HOST: $PROXMOX_HOST, VM_USERNAME: $VM_USERNAME)${ENDCOLOR}"
}
export -f load_secrets

# Source environment variables if cpc.env exists and set workspace-specific variables
load_env_vars() {
  local repo_root
  repo_root=$(get_repo_path)
  
  # Load secrets first
  load_secrets
  
  if [ -f "$repo_root/$CPC_ENV_FILE" ]; then # Changed from CCR_ENV_FILE
    # shellcheck source=cpc.env
    set -a # Automatically export all variables
    source "$repo_root/$CPC_ENV_FILE" # Changed from CCR_ENV_FILE
    set +a # Stop automatically exporting
    echo -e "${BLUE}Loaded environment variables from $CPC_ENV_FILE${ENDCOLOR}" # Changed from CCR_ENV_FILE
    
    # Export static IP configuration variables to Terraform
    if [ -n "$NETWORK_CIDR" ]; then
      export TF_VAR_network_cidr="$NETWORK_CIDR"
    fi
    if [ -n "$STATIC_IP_START" ]; then
      export TF_VAR_static_ip_start="$STATIC_IP_START"
    fi
    if [ -n "$WORKSPACE_IP_BLOCK_SIZE" ]; then
      export TF_VAR_workspace_ip_block_size="$WORKSPACE_IP_BLOCK_SIZE"
    fi
    if [ -n "$STATIC_IP_BASE" ]; then
      export TF_VAR_static_ip_base="$STATIC_IP_BASE"
    fi
    if [ -n "$STATIC_IP_GATEWAY" ]; then
      export TF_VAR_static_ip_gateway="$STATIC_IP_GATEWAY"
    fi
    
    # Set workspace-specific template variables based on current context
    # This function should only be called after REPO_PATH is set
    if [ -f "$CLUSTER_CONTEXT_FILE" ]; then
      local current_workspace
      current_workspace=$(cat "$CLUSTER_CONTEXT_FILE")
      set_workspace_template_vars "$current_workspace"
    fi
  else
    echo -e "${YELLOW}Warning: $CPC_ENV_FILE not found in repository root. Some default versions might be used by playbooks.${ENDCOLOR}" # Changed from CCR_ENV_FILE
  fi
}
export -f load_env_vars

# Set workspace-specific template variables based on current workspace
set_workspace_template_vars() {
  local workspace="$1"
  
  if [ -z "$workspace" ]; then
    echo -e "${YELLOW}Warning: No workspace specified for setting template variables${ENDCOLOR}"
    return 1
  fi
  
  # Path to the environment file
  local env_file="$REPO_PATH/envs/$workspace.env"
  
  # Check if the environment file exists
  if [[ ! -f "$env_file" ]]; then
    echo -e "${YELLOW}Warning: Environment file for workspace '$workspace' not found.${ENDCOLOR}"
    # Dynamically list available workspaces
    echo -ne "${BLUE}Available workspaces: ${ENDCOLOR}"
    ls -1 "$REPO_PATH/envs/" | grep -E '\.env$' | sed 's/\.env$//' | tr '\n' ', ' | sed 's/,$/\n/'
    return 1
  fi
  
  # Load variables from environment file
  source "$env_file"
  
  # Set default values for any variables that might be missing
  : "${TEMPLATE_VM_ID:=900}"
  : "${TEMPLATE_VM_NAME:=tpl-default-k8s}"
  : "${IMAGE_NAME:=default-image.img}"
  : "${IMAGE_LINK:=https://example.com/default-image.img}"
  : "${KUBERNETES_SHORT_VERSION:=1.29}"
  : "${KUBERNETES_MEDIUM_VERSION:=v1.29}"
  : "${KUBERNETES_VERSION:=$KUBERNETES_MEDIUM_VERSION}"
  : "${KUBERNETES_LONG_VERSION:=1.29.0}"
  : "${CNI_PLUGINS_VERSION:=v1.4.0}"
  : "${CALICO_VERSION:=v3.26.0}"
  : "${METALLB_VERSION:=v0.14.3}"
  : "${COREDNS_VERSION:=v1.10.1}"
  : "${METRICS_SERVER_VERSION:=v0.6.4}"
  : "${ETCD_VERSION:=v3.5.10}"
  : "${KUBELET_SERVING_CERT_APPROVER_VERSION:=v0.1.8}"
  : "${LOCAL_PATH_PROVISIONER_VERSION:=v0.0.24}"
  : "${CERT_MANAGER_VERSION:=v1.15.0}"
  : "${ARGOCD_VERSION:=v2.12.0}"
  : "${INGRESS_NGINX_VERSION:=v1.11.0}"
  
  echo -e "${BLUE}Set template variables for workspace '$workspace':${ENDCOLOR}"
  echo -e "${BLUE}  TEMPLATE_VM_ID: $TEMPLATE_VM_ID${ENDCOLOR}"
  echo -e "${BLUE}  TEMPLATE_VM_NAME: $TEMPLATE_VM_NAME${ENDCOLOR}"
  echo -e "${BLUE}  IMAGE_NAME: $IMAGE_NAME${ENDCOLOR}"
  echo -e "${BLUE}  KUBERNETES_VERSION: $KUBERNETES_MEDIUM_VERSION${ENDCOLOR}"
  echo -e "${BLUE}  CALICO_VERSION: $CALICO_VERSION${ENDCOLOR}"
  echo -e "${BLUE}  METALLB_VERSION: $METALLB_VERSION${ENDCOLOR}"
  echo -e "${BLUE}  COREDNS_VERSION: $COREDNS_VERSION${ENDCOLOR}"
  echo -e "${BLUE}  ETCD_VERSION: $ETCD_VERSION${ENDCOLOR}"
}
export -f set_workspace_template_vars

# TODO: Move to modules/20_ansible.sh - run_ansible_playbook function has been modularized as ansible_run_playbook()

display_usage() {
  echo "Usage: cpc <command> [options]"
  echo ""
  echo "Commands:"
  echo "  setup-cpc                      Initial setup for cpc command."
  echo "  ctx [<cluster_name>]           Get or set the current cluster context (Tofu workspace)."
  echo "  clone-workspace <src> <dst>    Clone a workspace environment to create a new one."
  echo "  delete-workspace <n>           Delete a workspace environment."
  echo "  template                       Creates a VM template for Kubernetes"
  echo "  run-playbook <playbook>        Run any Ansible playbook from ansible/playbooks/"
  echo "  run-command <target> \"<cmd>\"   Run a shell command on target host(s) or group."
  echo "  clear-ssh-hosts                Clear VM IP addresses from ~/.ssh/known_hosts"
  echo "  clear-ssh-maps                 Clear SSH control sockets and connections for VMs"
  echo "  load_secrets                   Load and display secrets from SOPS configuration"
  echo "  dns-pihole <action>            Manage Pi-hole DNS records. Actions: list, add, unregister-dns, interactive-add, interactive-unregister."
  echo "  generate-hostnames             Generate hostname configurations for VMs in Proxmox"
  echo "  scripts/<script_name>          Run any script from the scripts directory"
  echo "  deploy <tofu_cmd> [opts]       Run any 'tofu' command (e.g., plan, apply, output) in context."
  echo "  cluster-info                   Show simplified cluster information (VM_ID, hostname, IP)."
  echo ""
  echo "VM Management:"
  echo "  add-vm                         Interactively add a new VM (worker or control plane)."
  echo "  remove-vm                      Interactively remove a VM and update configuration."
  echo "  start-vms                      Start all VMs in the current context."
  echo "  stop-vms                       Stop all VMs in the current context."
  echo "  vmctl                          (Placeholder) Suggests using Tofu for VM control."
  echo ""
  echo "Kubernetes Management:"
  echo "  bootstrap                      Bootstrap a complete Kubernetes cluster on deployed VMs"
  echo "  get-kubeconfig                 Retrieve and merge Kubernetes cluster config into local kubeconfig."
  echo "  prepare-node <node>            Install Kubernetes components on a new VM before joining cluster."
  echo "  update-inventory               Update Ansible inventory cache from current cluster state."
  echo "  add-nodes                      Add new worker nodes to the cluster."
  echo "  remove-nodes                   Remove nodes from the Kubernetes cluster."
  echo "  drain-node <node_name>         Drain workloads from a node."
  echo "  upgrade-node <node_name>       Upgrade Kubernetes on a specific node."
  echo "  reset-node <node_name>         Reset Kubernetes on a specific node."
  echo "  reset-all-nodes                Reset Kubernetes on all nodes in the current context."
  echo "  upgrade-addons                 Install/upgrade cluster addons with interactive menu (CNI, MetalLB, cert-manager, ArgoCD, etc.)."
  echo "  configure-coredns              Configure CoreDNS to forward local domain queries to Pi-hole DNS server."
  echo "  upgrade-k8s                    Upgrade Kubernetes control plane."
  echo "  status|cluster-status          Check Kubernetes cluster status and health."
  echo ""
  echo "DNS/SSL Management:"
  echo "  regenerate-certificates        Regenerate Kubernetes certificates with DNS hostname support"
  echo "  test-dns <domain>              Test DNS resolution within the cluster"
  echo "  verify-certificates            Verify SSL certificate validity and SANs"
  echo "  check-cluster-dns              Comprehensive cluster DNS functionality check"
  echo "  inspect-cert <cert-path>       Inspect specific certificate file details"
  echo ""
  echo "Use 'cpc <command> --help' for more details on a specific command."
}

# --- Main Script Logic ---

# Ensure config directory exists
mkdir -p "$CONFIG_DIR"

# Check for essential commands early
check_required_commands "ansible-playbook" "ansible-inventory" "tofu" "kubectl" "jq"

COMMAND="$1"
shift # Remove command from arguments, rest are options

# Load REPO_PATH if not doing setup
if [[ "$COMMAND" != "setup-cpc" && "$COMMAND" != "" && "$COMMAND" != "-h" && "$COMMAND" != "--help" && "$COMMAND" != "help" ]]; then # Changed from setup-ccr
  REPO_PATH=$(get_repo_path)
  export REPO_PATH
  # Load environment variables from cpc.env
  load_env_vars # Will now use CPC_ENV_FILE
fi


case "$COMMAND" in
  setup-cpc) # Changed from setup-ccr
    cpc_core setup-cpc "$@"
    ;;

  get-kubeconfig)
    cpc_k8s_cluster get-kubeconfig "$@"
    ;;

  add-vm)
    cpc_proxmox add-vm "$@"
    ;;

  remove-vm)
    cpc_proxmox remove-vm "$@"
    ;;

  ctx)
    cpc_core ctx "$@"
    ;;
  
  clone-workspace)
    cpc_core clone-workspace "$@"
    ;;

  delete-workspace)
    cpc_core delete-workspace "$@"
    ;;
  
  template)
    cpc_proxmox template "$@"
    ;;

  load_secrets)
    cpc_core load_secrets "$@"
    ;;

  bootstrap)
    cpc_k8s_cluster bootstrap "$@"
    ;;

  run-playbook)
    cpc_ansible run-ansible "$@"
    ;;

  clear-ssh-hosts)
    cpc_ssh clear-ssh-hosts "$@"
    ;;

  clear-ssh-maps)
    cpc_ssh clear-ssh-maps "$@"
    ;;

  add-nodes)
    cpc_k8s_nodes add-nodes "$@"
    ;;

  prepare-node)
    cpc_k8s_nodes prepare-node "$@"
    ;;

  update-inventory)
    cpc_ansible update-inventory "$@"
    ;;

  remove-nodes)
    cpc_k8s_nodes remove-nodes "$@"
    ;;

  drain-node)
    cpc_k8s_nodes drain-node "$@"
    ;;

  upgrade-node)
    cpc_k8s_nodes upgrade-node "$@"
    ;;

  reset-node)
    cpc_k8s_nodes reset-node "$@"
    ;;

  reset-all-nodes)
    cpc_k8s_nodes reset-all-nodes "$@"
    ;;

  upgrade-addons)
    cpc_cluster_ops upgrade-addons "$@"
    ;;

  upgrade-k8s)
    cpc_k8s_cluster upgrade-k8s "$@"
    ;;

  status|cluster-status)
    cpc_k8s_cluster status "$@"
    ;;

  vmctl)
    cpc_proxmox vmctl "$@"
    ;;

  run-command)
    cpc_ansible run-command "$@"
    ;;

  dns-pihole)
    cpc_dns_pihole "$@"
    ;;

  cluster-info)
    cpc_tofu cluster-info "$@"
    ;;

  deploy)
    cpc_tofu deploy "$@"
    ;;

  generate-hostnames)
    cpc_tofu generate-hostnames "$@"
    ;;

  run-ansible)
    cpc_ansible run-ansible "$@"
    ;;

  gen_hostnames)
    cpc_tofu gen_hostnames "$@"
    ;;

  start-vms)
    cpc_tofu start-vms "$@"
    ;;

  configure-coredns)
    cpc_cluster_ops configure-coredns "$@"
    ;;

  # DNS/SSL commands
  regenerate-certificates|regenerate-cert)
    cpc_dns_ssl regenerate-certificates "$@"
    ;;

  test-dns|test-resolution)
    cpc_dns_ssl test-dns "$@"
    ;;

  verify-certificates|verify-cert|check-cert)
    cpc_dns_ssl verify-certificates "$@"
    ;;

  check-cluster-dns|test-cluster-dns)
    cpc_dns_ssl check-cluster-dns "$@"
    ;;

  inspect-cert|show-cert)
    cpc_dns_ssl inspect-cert "$@"
    ;;

  stop-vms)
    cpc_tofu stop-vms "$@"
    ;;

  "" | "-h" | "--help" | "help")
    display_usage
    ;;

  scripts/*)
    # Handle running scripts directly: ./cpc scripts/script_name.sh
    script_path="$REPO_PATH/$COMMAND"
    if [[ -f "$script_path" && -x "$script_path" ]]; then
      echo -e "${BLUE}Running script: $script_path${ENDCOLOR}"
      # Pass all remaining arguments to the script
      "$script_path" "$@"
    elif [[ -f "$script_path" ]]; then
      echo -e "${RED}Error: Script $script_path exists but is not executable.${ENDCOLOR}" >&2
      echo -e "${BLUE}Try: chmod +x $script_path${ENDCOLOR}" >&2
      exit 1
    else
      echo -e "${RED}Error: Script not found at $script_path${ENDCOLOR}" >&2
      exit 1
    fi
    ;;

  # Legacy aliases for backward compatibility
  add-node)
    echo -e "${YELLOW}Warning: 'add-node' is deprecated. Use 'add-vm' instead.${ENDCOLOR}"
    shift
    set -- "add-vm" "$@"
    exec "$0" "$@"
    ;;

  remove-node)
    echo -e "${YELLOW}Warning: 'remove-node' is deprecated. Use 'remove-vm' instead.${ENDCOLOR}"
    shift
    set -- "remove-vm" "$@"
    exec "$0" "$@"
    ;;

  update-pihole)
    echo -e "${YELLOW}Warning: 'update-pihole' is deprecated. Use 'dns-pihole' instead.${ENDCOLOR}"
    shift
    set -- "dns-pihole" "$@"
    exec "$0" "$@"
    ;;

  delete-node)
    echo -e "${YELLOW}Warning: 'delete-node' is deprecated. Use 'remove-nodes' instead.${ENDCOLOR}"
    # Pass all arguments as is to remove-nodes
    set -- "remove-nodes" "$@"
    exec "$0" "$@"
    ;;

  *)
    echo -e "${RED}Unknown command: $COMMAND${ENDCOLOR}" >&2
    display_usage
    exit 1
    ;;
esac

exit 0
