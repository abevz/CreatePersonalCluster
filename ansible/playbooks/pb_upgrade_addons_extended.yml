---
- name: Upgrade and Install Cluster Addons
  hosts: "{{ target_hosts | default('control_plane') }}"
  become: true
  gather_facts: false

  vars:
    addon_name: "{{ addon_name | default('all') }}"
    requested_version: "{{ addon_version | default('') }}"
    control_plane_node: "{{ groups['control_plane'][0] }}"

    # Cloudflare and Let's Encrypt settings
    cloudflare_api_token: "{{ lookup('env', 'CLOUDFLARE_DNS_API_TOKEN') }}"
    cloudflare_email: "{{ lookup('env', 'CLOUDFLARE_EMAIL') }}"
    letsencrypt_server: "https://acme-v02.api.letsencrypt.org/directory"

    # Default addon versions
    default_calico_version: "{{ calico_version | default('v3.28.0') }}"
    default_metallb_version: "{{ metallb_version | default('v0.14.8') }}"
    default_metrics_server_version: "{{ metrics_server_version | default('v0.7.2') }}"
    default_coredns_version: "{{ coredns_version | default('v1.11.3') }}"
    default_cert_manager_version: "{{ cert_manager_version | default('v1.16.2') }}"
    default_kubelet_serving_cert_approver_version: >-
      {{ kubelet_serving_cert_approver_version | default('v0.9.2') }}
    default_argocd_version: "{{ argocd_version | default('v2.13.2') }}"
    default_ingress_nginx_version: "{{ ingress_nginx_version | default('v1.12.0') }}"
    default_traefik_gateway_version: "{{ traefik_gateway_version | default('37.0.0') }}"
    default_gateway_api_version: "{{ gateway_api_version | default('v1.1.0') }}"

    # Resolved versions
    calico_target_version: >-
      {{ requested_version if requested_version != '' else default_calico_version }}
    metallb_target_version: >-
      {{ requested_version if requested_version != '' else default_metallb_version }}
    metrics_server_target_version: >-
      {{ requested_version if requested_version != '' else default_metrics_server_version }}
    coredns_target_version: >-
      {{ requested_version if requested_version != '' else default_coredns_version }}
    cert_manager_target_version: >-
      {{ requested_version if requested_version != '' else default_cert_manager_version }}
    kubelet_serving_cert_approver_target_version: >-
      {{ requested_version if requested_version != ''
        else default_kubelet_serving_cert_approver_version }}
    argocd_target_version: >-
      {{ requested_version if requested_version != '' else default_argocd_version }}
    ingress_nginx_target_version: >-
      {{ requested_version if requested_version != '' else default_ingress_nginx_version }}
    traefik_gateway_target_version: >-
      {{ requested_version if requested_version != '' else default_traefik_gateway_version }}
    gateway_api_target_version: >-
      {{ requested_version if requested_version != '' else default_gateway_api_version }}

  pre_tasks:
    - name: Ensure bash is installed for shell tasks
      ansible.builtin.package:
        name: bash
        state: present

  tasks:
    - name: Set target host to control plane
      ansible.builtin.set_fact:
        ansible_host: "{{ hostvars[control_plane_node]['ansible_host'] }}"
      when: inventory_hostname != control_plane_node

    # ===========================
    # METRICS SERVER
    # ===========================
    - name: Check current Metrics Server version
      shell: kubectl get deployment -n kube-system metrics-server -o jsonpath='{.spec.template.spec.containers[0].image}' | cut -d':' -f2
      register: current_metrics_server_version
      when: addon_name in ['metrics-server', 'all']
      ignore_errors: yes

    - name: Upgrade Metrics Server
      block:
        - name: Download Metrics Server manifests
          get_url:
            url: "https://github.com/kubernetes-sigs/metrics-server/releases/download/{{ metrics_server_target_version }}/components.yaml"
            dest: "/tmp/metrics-server-{{ metrics_server_target_version }}.yaml"

        - name: Patch Metrics Server for self-hosted clusters
          shell: |
            sed -i '/--metric-resolution=15s/a\        - --kubelet-insecure-tls' /tmp/metrics-server-{{ metrics_server_target_version }}.yaml

        - name: Apply Metrics Server manifests
          shell: kubectl apply -f /tmp/metrics-server-{{ metrics_server_target_version }}.yaml

        - name: Wait for Metrics Server to be ready
          shell: kubectl wait --for=condition=ready pod -l k8s-app=metrics-server -n kube-system --timeout=300s

        - name: Verify Metrics Server upgrade
          shell: kubectl get deployment -n kube-system metrics-server -o jsonpath='{.spec.template.spec.containers[0].image}' | cut -d':' -f2
          register: new_metrics_server_version

        - name: Display Metrics Server upgrade result
          debug:
            msg:
              - "Metrics Server upgrade completed"
              - "Previous version: {{ current_metrics_server_version.stdout | default('unknown') }}"
              - "Current version: {{ new_metrics_server_version.stdout }}"

      when: addon_name in ['metrics-server', 'all'] and current_metrics_server_version is not failed

    # ===========================
    # CALICO CNI
    # ===========================
    - name: Check current Calico version
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          kubectl get pods -n calico-system -o jsonpath='{.items[0].spec.containers[0].image}' \
          | cut -d':' -f2 2>/dev/null || echo "not_installed"
        executable: /bin/bash
      register: current_calico_version
      changed_when: false
      ignore_errors: true
      when: addon_name in ['calico', 'all']

    - name: Upgrade Calico CNI
      when: addon_name in ['calico', 'all']
      block:
        - name: Download Calico operator manifest
          ansible.builtin.get_url:
            url: "https://raw.githubusercontent.com/projectcalico/calico/{{ calico_target_version }}/manifests/tigera-operator.yaml"
            dest: "/tmp/tigera-operator-{{ calico_target_version }}.yaml"
            mode: '0644'

        - name: Download Calico custom resources
          ansible.builtin.get_url:
            url: "https://raw.githubusercontent.com/projectcalico/calico/{{ calico_target_version }}/manifests/custom-resources.yaml"
            dest: "/tmp/calico-custom-resources-{{ calico_target_version }}.yaml"
            mode: '0644'

        - name: Check if Calico is already running and healthy
          ansible.builtin.shell:
            cmd: |
              set -o pipefail
              kubectl get pods -n calico-system -l k8s-app=calico-node \
              --field-selector=status.phase=Running 2>/dev/null | grep -c calico-node || echo "0"
            executable: /bin/bash
          register: calico_running_pods
          changed_when: false
          ignore_errors: true

        - name: Check if exact same version is already installed
          ansible.builtin.shell:
            cmd: |
              set -o pipefail
              if [ "{{ calico_running_pods.stdout }}" -gt 0 ]; then
                current_version=$(kubectl get pods -n calico-system \
                -o jsonpath='{.items[0].spec.containers[0].image}' | cut -d':' -f2 2>/dev/null)
                if [ "$current_version" = "{{ calico_target_version }}" ]; then
                  echo "same_version"
                else
                  echo "different_version"
                fi
              else
                echo "not_running"
              fi
            executable: /bin/bash
          register: calico_version_check
          changed_when: false

        - name: Display Calico version check result
          ansible.builtin.debug:
            msg:
              - "Calico running pods: {{ calico_running_pods.stdout }}"
              - "Version check result: {{ calico_version_check.stdout }}"
              - "Current version: {{ current_calico_version.stdout }}"
              - "Target version: {{ calico_target_version }}"

        - name: Apply Calico operator
          ansible.builtin.command: >
            kubectl apply -f /tmp/tigera-operator-{{ calico_target_version }}.yaml
          register: calico_apply_result
          changed_when: "'configured' in calico_apply_result.stdout or 'created' in calico_apply_result.stdout"
          when: calico_version_check.stdout != "same_version"

        - name: Wait for tigera operator to be ready
          ansible.builtin.command: >
            kubectl wait --for=condition=ready pod
            -l k8s-app=tigera-operator -n tigera-operator --timeout=300s
          changed_when: false
          when: calico_version_check.stdout != "same_version"

        - name: Apply Calico custom resources
          ansible.builtin.command: >
            kubectl apply -f /tmp/calico-custom-resources-{{ calico_target_version }}.yaml
          register: calico_cr_result
          changed_when: "'configured' in calico_cr_result.stdout or 'created' in calico_cr_result.stdout"
          when: calico_version_check.stdout != "same_version"

        - name: Wait for Calico pods to be ready
          ansible.builtin.command: >
            kubectl wait --for=condition=ready pod
            -l k8s-app=calico-node -n calico-system --timeout=300s
          changed_when: false
          when: calico_version_check.stdout != "same_version"

        - name: Verify Calico installation
          ansible.builtin.shell:
            cmd: |
              set -o pipefail
              kubectl get pods -n calico-system -o jsonpath='{.items[0].spec.containers[0].image}' \
              | cut -d':' -f2 2>/dev/null || echo "verification_failed"
            executable: /bin/bash
          register: new_calico_version
          changed_when: false

        - name: Display Calico installation result
          ansible.builtin.debug:
            msg:
              - "Calico installation completed"
              - "Previous version: {{ current_calico_version.stdout | default('unknown') }}"
              - "Current version: {{ new_calico_version.stdout }}"
              - "Installation was {{ 'skipped' if calico_version_check.stdout == 'same_version' else 'applied' }}"

    # ===========================
    # METALLB
    # ===========================
    - name: Check current MetalLB version
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          kubectl get deployment -n metallb-system controller \
          -o jsonpath='{.spec.template.spec.containers[0].image}' | cut -d':' -f2
        executable: /bin/bash
      register: current_metallb_version
      changed_when: false
      ignore_errors: true
      when: addon_name in ['metallb', 'all']

    - name: Install/Upgrade MetalLB
      when: addon_name in ['metallb', 'all']
      block:
        - name: Apply MetalLB native manifests
          ansible.builtin.command: >
            kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/{{ metallb_target_version }}/config/manifests/metallb-native.yaml
          register: metallb_apply_result
          changed_when: "'configured' in metallb_apply_result.stdout or 'created' in metallb_apply_result.stdout"

        - name: Wait for MetalLB pods to be ready
          ansible.builtin.command: >
            kubectl wait --for=condition=ready pod
            -l app=metallb -n metallb-system --timeout=300s
          changed_when: false

        - name: Create MetalLB IP pool configuration
          ansible.builtin.shell:
            cmd: |
              kubectl apply -f - <<EOF
              apiVersion: metallb.io/v1beta1
              kind: IPAddressPool
              metadata:
                name: default-pool
                namespace: metallb-system
              spec:
                addresses:
                - 10.10.10.200-10.10.10.220
              ---
              apiVersion: metallb.io/v1beta1
              kind: L2Advertisement
              metadata:
                name: default
                namespace: metallb-system
              spec:
                ipAddressPools:
                - default-pool
              EOF
            executable: /bin/bash
          register: metallb_pool_result
          changed_when: "'configured' in metallb_pool_result.stdout or 'created' in metallb_pool_result.stdout"

        - name: Verify MetalLB installation
          ansible.builtin.shell:
            cmd: |
              set -o pipefail
              kubectl get deployment -n metallb-system controller \
              -o jsonpath='{.spec.template.spec.containers[0].image}' | cut -d':' -f2
            executable: /bin/bash
          register: new_metallb_version
          changed_when: false

        - name: Display MetalLB installation result
          ansible.builtin.debug:
            msg:
              - "MetalLB installation completed"
              - "Previous version: {{ current_metallb_version.stdout | default('not installed') }}"
              - "Current version: {{ new_metallb_version.stdout }}"

    # ===========================
    # CERT-MANAGER
    # ===========================
    - name: Check current cert-manager version
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          kubectl get deployment -n cert-manager cert-manager \
          -o jsonpath='{.spec.template.spec.containers[0].image}' | cut -d':' -f2
        executable: /bin/bash
      register: current_cert_manager_version
      changed_when: false
      ignore_errors: true
      when: addon_name in ['cert-manager', 'all']

    - name: Install/Upgrade cert-manager
      when: addon_name in ['cert-manager', 'all']
      block:
        - name: Add cert-manager Helm repository
          ansible.builtin.command: helm repo add jetstack https://charts.jetstack.io
          changed_when: false
          delegate_to: "{{ control_plane_node }}"

        - name: Update Helm repositories
          ansible.builtin.command: helm repo update
          changed_when: false
          delegate_to: "{{ control_plane_node }}"

        - name: Apply cert-manager with Gateway API support
          ansible.builtin.shell:
            cmd: |
              helm upgrade --install cert-manager jetstack/cert-manager \
                --namespace cert-manager \
                --create-namespace \
                --version {{ cert_manager_target_version | d('v1.16.2') }} \
                --set installCRDs=true \
                --set extraArgs[0]="--enable-gateway-api"
            executable: /bin/bash
          register: helm_install_cert_manager
          changed_when: "'already exists' not in helm_install_cert_manager.stderr"

        - name: Wait for cert-manager pods to be ready
          ansible.builtin.command: >
            kubectl wait --for=condition=ready pod
            -l app.kubernetes.io/instance=cert-manager -n cert-manager --timeout=300s
          changed_when: false

    - name: Configure Cloudflare ClusterIssuer
      when:
        - addon_name in ['cert-manager', 'all']
        - cloudflare_api_token is defined
        - cloudflare_api_token != ''
      block:
        - name: Create Cloudflare API token secret
          ansible.builtin.shell:
            cmd: |
              set -o pipefail
              kubectl create secret generic cloudflare-api-token \
                --from-literal=api-token={{ cloudflare_api_token }} \
                -n cert-manager --dry-run=client -o yaml | kubectl apply -f -
            executable: /bin/bash
          register: secret_result
          changed_when: "'created' in secret_result.stdout or 'configured' in secret_result.stdout"

        - name: Create Cloudflare ClusterIssuer
          ansible.builtin.shell:
            cmd: |
              kubectl apply -f - <<EOF
              apiVersion: cert-manager.io/v1
              kind: ClusterIssuer
              metadata:
                name: letsencrypt-cloudflare
              spec:
                acme:
                  email: {{ cloudflare_email }}
                  server: "{{ letsencrypt_server }}"
                  privateKeySecretRef:
                    name: letsencrypt-private-key
                  solvers:
                  - dns01:
                      cloudflare:
                        email: {{ cloudflare_email }}
                        apiTokenSecretRef:
                          name: cloudflare-api-token
                          key: api-token
              EOF
            executable: /bin/bash
          register: issuer_result
          changed_when: "'created' in issuer_result.stdout or 'configured' in issuer_result.stdout"

    # ===========================
    # ARGOCD
    # ===========================
    - name: Install/Upgrade ArgoCD
      when: addon_name in ['argocd', 'all']
      block:
        - name: Create ArgoCD namespace
          ansible.builtin.command: kubectl create namespace argocd
          register: argocd_ns_result
          changed_when: "'created' in argocd_ns_result.stdout"
          failed_when: "'already exists' not in argocd_ns_result.stderr and argocd_ns_result.rc != 0"

        - name: Apply ArgoCD
          ansible.builtin.command: >
            kubectl apply -n argocd
            -f https://raw.githubusercontent.com/argoproj/argo-cd/{{ argocd_target_version }}/manifests/install.yaml
          register: argocd_apply_result
          changed_when: "'configured' in argocd_apply_result.stdout or 'created' in argocd_apply_result.stdout"

        - name: Wait for ArgoCD pods to be ready
          ansible.builtin.command: >
            kubectl wait --for=condition=ready pod
            -l app.kubernetes.io/name=argocd-server -n argocd --timeout=600s
          changed_when: false

    # ===========================
    # INGRES NGINX
    # ===========================
    - name: Check current ingress-nginx version
      shell: kubectl get deployment -n ingress-nginx ingress-nginx-controller -o jsonpath='{.spec.template.spec.containers[0].image}' | cut -d':' -f2
      register: current_ingress_nginx_version
      when: addon_name in ['ingress-nginx', 'all']
      ignore_errors: true

    - name: Install/Upgrade ingress-nginx
      block:
        - name: Apply ingress-nginx
          shell: kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-{{ ingress_nginx_target_version }}/deploy/static/provider/baremetal/deploy.yaml

        - name: Wait for ingress-nginx pods to be ready
          shell: kubectl wait --for=condition=ready pod -l app.kubernetes.io/component=controller -n ingress-nginx --timeout=300s

        - name: Verify ingress-nginx installation
          shell: kubectl get deployment -n ingress-nginx ingress-nginx-controller -o jsonpath='{.spec.template.spec.containers[0].image}' | cut -d':' -f2
          register: new_ingress_nginx_version

        - name: Display ingress-nginx installation result
          debug:
            msg:
              - "ingress-nginx installation completed"
              - "Previous version: {{ current_ingress_nginx_version.stdout | default('not installed') }}"
              - "Current version: {{ new_ingress_nginx_version.stdout }}"

      when: addon_name in ['ingress-nginx', 'all']

    # ===========================
    # TRAEFIK
    # ===========================
    - name: Install Traefik Gateway
      block:
        - name: Ensure Helm is installed on the control plane
          shell: |
            if ! command -v helm &> /dev/null; then
              echo "Helm not found. Installing..."
              curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
              chmod 700 get_helm.sh
              ./get_helm.sh
              rm ./get_helm.sh
            else
              echo "Helm is already installed."
            fi
          register: helm_install_check
          changed_when: "'Helm not found' in helm_install_check.stdout"

        - name: Add Traefik Helm repository
          shell: helm repo add traefik https://helm.traefik.io/traefik && helm repo update
          register: helm_repo_add_result
          changed_when: "'Adding existing repo' not in helm_repo_add_result.stdout"

        - name: Install Gateway API CRDs
          shell: kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/{{ gateway_api_target_version }}/standard-install.yaml

        - name: Install/Upgrade Traefik
          shell: |
            echo "{{ lookup('file', 'traefik-values.yaml') }}" | helm upgrade --install traefik traefik/traefik \
              --namespace traefik \
              --create-namespace \
              --version {{ traefik_gateway_target_version }} \
              -f -
          register: helm_install_result
          changed_when: "'already exists' not in helm_install_result.stderr"

        - name: Wait for Traefik pods to be ready
          shell: kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=traefik -n traefik --timeout=300s

        - name: Verify Traefik installation
          shell: helm list -n traefik -f traefik -o json | jq -r '.[0].app_version'
          register: new_traefik_gateway_version

        - name: Display Traefik installation result
          debug:
            msg:
              - "Traefik Gateway installation completed"
              - "Current version: {{ new_traefik_gateway_version.stdout }}"

      when: addon_name in ['traefik-gateway', 'all']          

    # ===========================
    # CoreDNS
    # ===========================
    - name: Check current CoreDNS version
      shell: kubectl get deployment -n kube-system coredns -o jsonpath='{.spec.template.spec.containers[0].image}' | cut -d':' -f2
      register: current_coredns_version
      when: addon_name in ['coredns', 'all']
      ignore_errors: true

    - name: Upgrade CoreDNS
      when: addon_name in ['coredns', 'all'] and current_coredns_version is not failed
      block:
        - name: Update CoreDNS image
          shell: |
            kubectl set image deployment/coredns -n kube-system \
              coredns=registry.k8s.io/coredns/coredns:{{ coredns_target_version }}

        - name: Wait for CoreDNS rollout to complete
          shell: kubectl rollout status deployment/coredns -n kube-system --timeout=300s

        - name: Verify CoreDNS upgrade
          shell: kubectl get deployment -n kube-system coredns -o jsonpath='{.spec.template.spec.containers[0].image}' | cut -d':' -f2
          register: new_coredns_version

        - name: Display CoreDNS upgrade result
          debug:
            msg:
              - "CoreDNS upgrade completed"
              - "Previous version: {{ current_coredns_version.stdout | default('unknown') }}"
              - "Current version: {{ new_coredns_version.stdout }}"


    # ===========================
    # CLEANUP
    # ===========================
    - name: Cleanup temporary files
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop:
        - "/tmp/tigera-operator-{{ calico_target_version }}.yaml"
        - "/tmp/calico-custom-resources-{{ calico_target_version }}.yaml"
        - "/tmp/metrics-server-{{ metrics_server_target_version }}.yaml"
      when: addon_name in ['calico', 'metrics-server', 'all']

