---
# Improved Kubernetes cluster initialization playbook that supports DNS hostnames in certificates
- name: Initialize Kubernetes Cluster with DNS hostname support
  hosts: control_plane
  become: yes
  gather_facts: yes
  vars:
    pod_cidr: "192.168.0.0/16"  # Default for Calico
    kubernetes_version: "{{ KUBERNETES_LONG_VERSION | default('1.29') }}"
    harbor_hostname: "{{ HARBOR_HOSTNAME }}" 
    harbor_robot_username: "{{ HARBOR_ROBOT_USER | default('k8s-puller') }}"
    harbor_robot_token: "{{ HARBOR_ROBOT_TOKEN | default('') }}" 
    target_namespaces:
      - default
      - kube-system
        
  tasks:
    - name: Check if cluster is already initialized
      ansible.builtin.stat:
        path: /etc/kubernetes/admin.conf
      register: kubeconfig_exists

    - name: Get hostname and FQDN
      ansible.builtin.setup:
        filter: ansible_hostname,ansible_fqdn
      register: hostname_facts

    - name: Display hostname information
      ansible.builtin.debug:
        msg: |
          Hostname: {{ ansible_hostname }}
          FQDN: {{ ansible_fqdn }}
          IP: {{ ansible_default_ipv4.address }}

    - name: Create kubeadm configuration file with DNS hostname support
      ansible.builtin.copy:
        dest: /tmp/kubeadm-config.yaml
        content: |
          ---
          apiVersion: kubeadm.k8s.io/v1beta3
          kind: InitConfiguration
          localAPIEndpoint:
            advertiseAddress: {{ ansible_default_ipv4.address }}
            bindPort: 6443
          nodeRegistration:
            kubeletExtraArgs:
              node-ip: {{ ansible_default_ipv4.address }}
          ---
          apiVersion: kubeadm.k8s.io/v1beta3
          kind: ClusterConfiguration
          kubernetesVersion: {{ kubernetes_version }}
          controlPlaneEndpoint: "{{ ansible_fqdn }}:6443"
          apiServer:
            certSANs:
            - {{ ansible_default_ipv4.address }}
            - {{ ansible_hostname }}
            - {{ ansible_fqdn }}
            - localhost
            - 127.0.0.1
            - kubernetes
            - kubernetes.default
            - kubernetes.default.svc
            - kubernetes.default.svc.cluster.local
          networking:
            dnsDomain: cluster.local
            podSubnet: {{ pod_cidr }}
            serviceSubnet: 10.96.0.0/12
          ---
          apiVersion: kubelet.config.k8s.io/v1beta1
          kind: KubeletConfiguration
          cgroupDriver: systemd
          serverTLSBootstrap: true
        mode: '0644'
      when: not kubeconfig_exists.stat.exists

    - name: Initialize Kubernetes cluster with custom configuration
      ansible.builtin.command: kubeadm init --config=/tmp/kubeadm-config.yaml
      register: kubeadm_init_result
      when: not kubeconfig_exists.stat.exists
      changed_when: true

    - name: Create .kube directory for root
      ansible.builtin.file:
        path: /root/.kube
        state: directory
        mode: '0755'
      when: not kubeconfig_exists.stat.exists

    - name: Copy admin.conf to root's kube config
      ansible.builtin.copy:
        src: /etc/kubernetes/admin.conf
        dest: /root/.kube/config
        remote_src: yes
        owner: root
        group: root
        mode: '0644'
      when: not kubeconfig_exists.stat.exists

    - name: Create .kube directory for regular user
      ansible.builtin.file:
        path: /home/{{ ansible_user }}/.kube
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      when: not kubeconfig_exists.stat.exists

    - name: Copy admin.conf to user's kube config
      ansible.builtin.copy:
        src: /etc/kubernetes/admin.conf
        dest: /home/{{ ansible_user }}/.kube/config
        remote_src: yes
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
      when: not kubeconfig_exists.stat.exists

    - name: Extract join command
      ansible.builtin.shell: kubeadm token create --print-join-command
      register: join_command_output
      when: not kubeconfig_exists.stat.exists

    - name: Save join command to file
      ansible.builtin.copy:
        content: "{{ join_command_output.stdout }}"
        dest: /tmp/kubeadm_join_command.sh
        mode: '0755'
      when: not kubeconfig_exists.stat.exists

    - name: Fetch join command to local machine
      ansible.builtin.fetch:
        src: /tmp/kubeadm_join_command.sh
        dest: /tmp/kubeadm_join_command.sh
        flat: yes
      when: not kubeconfig_exists.stat.exists

    - name: Display cluster initialization status
      ansible.builtin.debug:
        msg: |
          Kubernetes cluster initialized successfully!
          Control plane endpoint: {{ ansible_fqdn }}:6443
          Join command saved to /tmp/kubeadm_join_command.sh
          
          Certificate SANs include:
          - IP: {{ ansible_default_ipv4.address }}
          - Hostname: {{ ansible_hostname }}
          - FQDN: {{ ansible_fqdn }}
          
          Next steps:
          1. Install CNI plugin (Calico)
          2. Join worker nodes
      when: not kubeconfig_exists.stat.exists

- name: Install Calico CNI Plugin
  hosts: control_plane
  become: yes
  gather_facts: no
  tasks:
    - name: Check if Calico is already installed
      ansible.builtin.shell: kubectl get pods -n calico-system --no-headers 2>/dev/null | wc -l
      register: calico_pods_count
      failed_when: false
      changed_when: false

    - name: Install Calico CNI
      ansible.builtin.shell: |
        kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.28.0/manifests/tigera-operator.yaml
        kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.28.0/manifests/custom-resources.yaml
      when: calico_pods_count.stdout == "0"
      register: calico_install_result
      changed_when: true

    - name: Wait for Calico pods to be created before checking their status
      ansible.builtin.shell: kubectl get pods -n calico-system --no-headers
      register: calico_pod_list
      until: calico_pod_list.stdout_lines | length > 0
      retries: 20
      delay: 15
      when: calico_install_result.changed
      changed_when: false

    - name: Wait for Calico Deployments to be available
      command: "kubectl wait --for=condition=Available deployment --all -n calico-system --timeout=300s"
      register: calico_deploy_wait_result
      changed_when: true
      delegate_to: "{{ groups['control_plane'][0] }}"

    - name: Wait for Calico DaemonSet to be ready
      command: "kubectl rollout status daemonset/calico-node -n calico-system --timeout=300s"
      register: calico_ds_wait_result
      changed_when: true
      delegate_to: "{{ groups['control_plane'][0] }}"

- name: Join Worker Nodes to Cluster
  hosts: workers
  become: yes
  gather_facts: yes
  tasks:
    - name: Check if node is already part of cluster
      ansible.builtin.stat:
        path: /etc/kubernetes/kubelet.conf
      register: kubelet_conf_exists

    - name: Copy join command to worker nodes
      ansible.builtin.copy:
        src: /tmp/kubeadm_join_command.sh
        dest: /tmp/kubeadm_join_command.sh
        mode: '0755'
      when: not kubelet_conf_exists.stat.exists

    - name: Join worker nodes to cluster
      ansible.builtin.shell: /tmp/kubeadm_join_command.sh
      when: not kubelet_conf_exists.stat.exists
      register: join_result
      changed_when: true

    - name: Display join result
      ansible.builtin.debug:
        msg: "Worker node {{ inventory_hostname }} joined cluster successfully"
      when: not kubelet_conf_exists.stat.exists

- name: Verify Cluster Status
  hosts: control_plane
  become: yes
  gather_facts: no
  tasks:
    - name: Get cluster nodes
      ansible.builtin.shell: kubectl get nodes -o wide
      register: cluster_nodes
      changed_when: false

    - name: Display cluster status
      ansible.builtin.debug:
        msg: |
          Cluster Status:
          {{ cluster_nodes.stdout }}

    - name: Get cluster pods
      ansible.builtin.shell: kubectl get pods --all-namespaces
      register: cluster_pods
      changed_when: false

    - name: Display pod status
      ansible.builtin.debug:
        msg: |
          Pod Status:
          {{ cluster_pods.stdout }}

    - name: Verify API server certificate includes hostname
      ansible.builtin.shell: |
        openssl x509 -in /etc/kubernetes/pki/apiserver.crt -text -noout | grep -A 10 "Subject Alternative Name"
      register: cert_sans
      changed_when: false

    - name: Display certificate SANs
      ansible.builtin.debug:
        msg: |
          API Server Certificate SANs:
          {{ cert_sans.stdout }}

    - name: Wait for all nodes to report Ready status
      delegate_to: "{{ groups['control_plane'][0] }}"
      command: "kubectl wait --for=condition=Ready nodes --all --timeout=300s"
      tags:
        - bootstrap

    - name: Wait for all worker node CSRs to appear and approve them
      delegate_to: "{{ groups['control_plane'][0] }}"
      tags:
        - bootstrap
      block:
        - name: Wait until all worker CSRs are created
          # Use jsonpath so kubectl filters and returns only the names of the required CSRs
          command: >
            kubectl get csr -o jsonpath='{.items[?(@.spec.signerName=="kubernetes.io/kubelet-serving")].metadata.name}'
          register: pending_csr_names
          # The condition became very simple: count the number of words in the output
          until: "pending_csr_names.stdout.split(' ') | length >= (groups['workers'] | length)"
          retries: 30
          delay: 10
          changed_when: false

        - name: Approve all found kubelet serving CSRs
          # We use the result of the previous command directly
          command: "kubectl certificate approve {{ item }}"
          loop: "{{ pending_csr_names.stdout.split(' ') }}"
          when: pending_csr_names.stdout | length > 0
          changed_when: true

        - name: Display CSR approval status
          ansible.builtin.debug:
            msg: "Successfully approved {{ pending_csr_names.stdout.split() | length }} pending kubelet serving CSRs."
          when: pending_csr_names.stdout | length > 0

    - name: Final cluster status verification
      ansible.builtin.shell: kubectl get nodes -o wide
      register: final_cluster_status
      changed_when: false

    - name: Display final cluster status
      ansible.builtin.debug:
        msg: |
          Final Cluster Status (with DNS hostnames):
          {{ final_cluster_status.stdout }}

- name: Configure Harbor Integration
  hosts: control_plane
  become: yes
  gather_facts: no
  vars:
    # These variables, including target_namespaces, are visible only here
    target_namespaces:
      - default
      - kube-system

  tasks:
    - name: Check if Harbor robot token is provided
      ansible.builtin.fail:
        msg: "Harbor robot token is not defined. Please pass it using -e 'HARBOR_ROBOT_TOKEN=your_token'"
      when: harbor_robot_token | length == 0

    - name: Create Harbor pull secret in target namespaces
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: registry-creds
            namespace: "{{ item }}"
          type: kubernetes.io/dockerconfigjson
          data:
            .dockerconfigjson: >-
              {{
                {
                  "auths": {
                    (harbor_hostname): {
                      "username": harbor_robot_username,
                      "password": harbor_robot_token,
                      "auth": (harbor_robot_username + ":" + harbor_robot_token) | b64encode
                    }
                  }
                } | to_json | b64encode
              }}
      loop: "{{ target_namespaces }}"
